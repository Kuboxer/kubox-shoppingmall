name: Backend MSA Deploy with Smart Detection

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'

jobs:
  sonarqube-analysis:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache SonarQube packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Make gradlew executable
        run: |
          find backend/ -name "gradlew" -exec chmod +x {} \;

      - name: Build and Test with Gradle
        run: |
          echo "üî® Building and testing all backend services..."
          for service in backend/*/; do
            if [ -f "$service/build.gradle" ]; then
              service_name=$(basename "$service")
              echo "üì¶ Building $service_name..."
              cd "$service"
              ./gradlew clean build -x test
              ./gradlew test --continue || true
              cd ../..
            fi
          done

      - name: Build services for SonarQube
        run: |
          echo "üî® Building services for SonarQube analysis..."
          for service in backend/*/; do
            if [ -f "$service/build.gradle" ]; then
              service_name=$(basename "$service")
              echo "üì¶ Building $service_name for analysis..."
              cd "$service"
              ./gradlew clean compileJava compileTestJava
              cd ../..
            fi
          done

      - name: Run SonarQube Scan
        run: |
          wget -q https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip
          unzip -q sonar-scanner-cli-4.8.0.2856-linux.zip
          export PATH=$PATH:$(pwd)/sonar-scanner-4.8.0.2856-linux/bin
          
          sonar-scanner \
            -Dsonar.projectKey=kubox-shopping-mall \
            -Dsonar.sources=backend \
            -Dsonar.java.binaries=backend/user-service/build/classes/java/main,backend/product-service/build/classes/java/main,backend/cart-service/build/classes/java/main,backend/order-service/build/classes/java/main,backend/payment-service/build/classes/java/main \
            -Dsonar.java.test.binaries=backend/user-service/build/classes/java/test,backend/product-service/build/classes/java/test,backend/cart-service/build/classes/java/test,backend/order-service/build/classes/java/test,backend/payment-service/build/classes/java/test \
            -Dsonar.exclusions="**/build/**,**/gradle/**,**/gradlew,**/gradlew.bat,**/.gradle/**" \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.token=${{ secrets.SONAR_TOKEN }}

      - name: üìä SonarQube Analysis Complete
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "#36a64f",
                "title": "üîç SonarQube Code Analysis Completed",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "‚úÖ Code analysis completed successfully\\n‚è≥ Manual approval required to proceed",
                    "short": false
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  manual-approval:
    name: üîç Manual Approval
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Display Approval Information
        run: |
          echo "üîç Code Quality Analysis Complete!"
          echo "‚è≥ This deployment requires manual approval."
          echo "üë• Approved reviewers: IluvRiver, JH2050, choiyunha"
          echo "üöÄ Ready to proceed with deployment!"

      - name: ‚è≥ Manual Approval Required
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "#ff9500",
                "title": "‚è≥ Manual Approval Required for Deployment",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "üîç SonarQube analysis completed - Waiting for approval",
                    "short": false
                  },
                  {
                    "title": "üë• Reviewers",
                    "value": "@IluvRiver @JH2050 @choiyunha",
                    "short": false
                  },
                  {
                    "title": "üîó Review & Approve",
                    "value": "<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|Click here to approve>",
                    "short": false
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  build-and-deploy:
    name: üöÄ Build and Deploy
    needs: [sonarqube-analysis, manual-approval]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: üöÄ Deployment Approved
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "#36a64f",
                "title": "üöÄ Deployment Approved - Starting Build Process",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "‚úÖ Manual approval received\\nüèóÔ∏è Starting Docker image build...",
                    "short": false
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Detect services to build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          ALL_SERVICES=("user-service" "product-service" "order-service" "payment-service" "cart-service")
          BUILD_SERVICES=""
          
          # ECRÏóê Ïù¥ÎØ∏ÏßÄÍ∞Ä ÌïòÎÇòÎùºÎèÑ ÏûàÎäîÏßÄ ÌôïÏù∏
          TOTAL_IMAGES=$(aws ecr describe-images \
            --repository-name kubox \
            --query "length(imageDetails)" \
            --output text 2>/dev/null || echo "0")
          
          echo "üìä Total images in ECR: $TOTAL_IMAGES"
          
          if [ "$TOTAL_IMAGES" = "0" ]; then
            echo "üÜï No images found in ECR. Building ALL services for first time."
            BUILD_SERVICES="${ALL_SERVICES[@]}"
          else
            echo "üìã Images exist in ECR. Checking for changed services only."
            
            # Î≥ÄÍ≤ΩÎêú ÌååÏùº ÌôïÏù∏ (ÎãπÏã†Ïùò Í≤ÄÏ¶ùÎêú Î°úÏßÅ)
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            echo "üìÑ Changed files:"
            echo "$CHANGED_FILES"
            echo ""
            
            # Î≥ÄÍ≤ΩÎêú ÏÑúÎπÑÏä§ Ï∞æÍ∏∞ (Ï†ïÌôïÌïú Îß§Ïπ≠)
            for SERVICE in "${ALL_SERVICES[@]}"; do
              if echo "$CHANGED_FILES" | grep -q "backend/$SERVICE/"; then
                echo "‚úÖ Changes detected in: $SERVICE"
                BUILD_SERVICES="$BUILD_SERVICES $SERVICE"
              else
                echo "‚ö™ No changes in: $SERVICE"  
              fi
            done
            
            BUILD_SERVICES=$(echo $BUILD_SERVICES | xargs)
          fi
          
          if [ -z "$BUILD_SERVICES" ]; then
            echo ""
            echo "‚ÑπÔ∏è  No services need building. Exiting."
            echo "build_services=" >> $GITHUB_ENV
            echo "skip_build=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo ""
          echo "üéØ Services to build: $BUILD_SERVICES"
          echo "build_services=$BUILD_SERVICES" >> $GITHUB_ENV
          echo "skip_build=false" >> $GITHUB_ENV
          
          # SlackÏö© Ìè¨Îß∑ÌåÖ
          FORMATTED_SERVICES=$(echo $BUILD_SERVICES | sed 's/ /, /g')
          echo "formatted_services=$FORMATTED_SERVICES" >> $GITHUB_ENV
          
      - name: Build services
        if: env.skip_build != 'true' && env.build_services != ''
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Í≥†Ïú†ÏÑ±ÏùÑ ÏúÑÌïú ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BUILD_NUMBER="${{ github.run_number }}"
          
          # ÎπåÎìúÎêú ÏÑúÎπÑÏä§ÏôÄ Î≤ÑÏ†ÑÏùÑ Ï†ÄÏû•Ìï† Î∞∞Ïó¥
          BUILT_SERVICES=""
          
          for SERVICE in ${{ env.build_services }}; do
            echo "==================== Processing $SERVICE ===================="
            
            # ÌòÑÏû¨ ÏÑúÎπÑÏä§Ïùò Í∏∞Ï°¥ Î≤ÑÏ†Ñ ÌôïÏù∏
            echo "üîç Checking existing versions for $SERVICE..."
            EXISTING_VERSIONS=$(aws ecr describe-images \
              --repository-name kubox \
              --query "imageDetails[].imageTags[]" \
              --output text 2>/dev/null | \
              tr '\t' '\n' | \
              grep "^${SERVICE}-v[0-9]*$" | \
              sed "s/${SERVICE}-v//" | \
              sort -n || echo "")
            
            if [ -z "$EXISTING_VERSIONS" ]; then
              NEXT_VERSION=1
              echo "üÜï No existing versions found. Creating first version: v1"
            else
              echo "üìã Existing versions: $(echo $EXISTING_VERSIONS | tr '\n' ' ')"
              LATEST_VERSION=$(echo "$EXISTING_VERSIONS" | tail -1)
              NEXT_VERSION=$((LATEST_VERSION + 1))
              echo "üìà Latest version: v$LATEST_VERSION ‚Üí Next version: v$NEXT_VERSION"
            fi
            
            # ÏµúÏ¢Ö ÌÉúÍ∑∏Îì§
            VERSION_TAG="${SERVICE}-v${NEXT_VERSION}"
            LATEST_TAG="${SERVICE}-latest"
            
            # ÏûÑÏãú Í≥†Ïú† ÌÉúÍ∑∏ (Ï∂©Îèå Î∞©ÏßÄÏö©)
            TEMP_TAG="${SERVICE}-temp-${TIMESTAMP}-${BUILD_NUMBER}"
            
            VERSION_URI="$ECR_REGISTRY/kubox:$VERSION_TAG"
            LATEST_URI="$ECR_REGISTRY/kubox:$LATEST_TAG"
            
            echo "üèóÔ∏è  Building $SERVICE as $VERSION_TAG"
            
            # ÎèÑÏª§ ÎπåÎìú
            cd backend/$SERVICE
            
            if docker build --build-arg VERSION="$VERSION_TAG" -t "$TEMP_TAG" .; then
              echo "‚úÖ Build successful"
              
              # Î≤ÑÏ†Ñ ÌÉúÍ∑∏ Ï†ÅÏö© Î∞è Ìë∏Ïãú
              docker tag "$TEMP_TAG" "$VERSION_URI"
              if docker push "$VERSION_URI"; then
                echo "‚úÖ Successfully pushed $VERSION_TAG"
                
                # latest ÌÉúÍ∑∏ Ï†ÅÏö© Î∞è Ìë∏Ïãú
                docker tag "$TEMP_TAG" "$LATEST_URI"
                docker push "$LATEST_URI"
                echo "‚úÖ Updated $LATEST_TAG tag"
                
                # ÎπåÎìú ÏÑ±Í≥µÌïú ÏÑúÎπÑÏä§ Í∏∞Î°ù
                BUILT_SERVICES="$BUILT_SERVICES $SERVICE:$VERSION_TAG"
                
                echo "üéØ $SERVICE is now available as:"
                echo "   üì¶ $VERSION_TAG"
                echo "   üè∑Ô∏è  $LATEST_TAG"
                
              else
                echo "‚ùå Failed to push $VERSION_TAG"
              fi
              
              # ÏûÑÏãú ÌÉúÍ∑∏ Ï†ïÎ¶¨
              docker rmi "$TEMP_TAG" 2>/dev/null || true
              
            else
              echo "‚ùå Build failed for $SERVICE"
            fi
            
            cd ../..
            echo "---"
          done

          # ÎπåÎìú Í≤∞Í≥ºÎ•º ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ï†ÄÏû•
          echo "built_services=$BUILT_SERVICES" >> $GITHUB_ENV
          
          # SlackÏö© Ìè¨Îß∑ÌåÖ
          if [ -n "$BUILT_SERVICES" ]; then
            FORMATTED_BUILT=$(echo "$BUILT_SERVICES" | sed 's/ /\\n‚Ä¢ /g' | sed 's/:/: /g')
            echo "formatted_built_services=‚Ä¢ $FORMATTED_BUILT" >> $GITHUB_ENV
          fi

      - name: üöÄ Docker Build Complete
        if: success() && env.skip_build != 'true' && env.built_services != ''
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "#36a64f",
                "title": "üöÄ Docker Images Successfully Built and Pushed to ECR",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "üéØ Built Services",
                    "value": "${{ env.formatted_services }}",
                    "short": false
                  },
                  {
                    "title": "üì¶ New Images",
                    "value": "${{ env.formatted_built_services }}",
                    "short": false
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: ‚ÑπÔ∏è No Build Required
        if: env.skip_build == 'true'
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "#36a64f",
                "title": "‚ÑπÔ∏è No Docker Build Required",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Result",
                    "value": "‚úÖ SonarQube completed\\n‚ö™ No backend service changes detected\\n‚è≠Ô∏è Skipped Docker build",
                    "short": false
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      - name: Update Helm Chart
        if: env.skip_build != 'true' && env.built_services != ''
        run: |
          echo "üîÑ Updating Helm Chart with new image tags..."
          
          # Git ÏÑ§Ï†ï
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Helm Chart Ï†ÄÏû•ÏÜå ÌÅ¥Î°†
          if [ -n "${{ secrets.HELM_REPO_TOKEN }}" ]; then
            git clone https://${{ secrets.HELM_REPO_TOKEN }}@github.com/Kuboxer/kubox-helm-chart.git helm-repo
          else
            echo "‚ö†Ô∏è  HELM_REPO_TOKEN not set - skipping helm chart update"
            exit 0
          fi
          
          cd helm-repo
          
          # ÎπåÎìúÎêú Í∞Å ÏÑúÎπÑÏä§Ïùò ÌÉúÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
          for SERVICE_TAG in ${{ env.built_services }}; do
            SERVICE=$(echo $SERVICE_TAG | cut -d':' -f1)
            TAG=$(echo $SERVICE_TAG | cut -d':' -f2)
            
            echo "üìù Updating $SERVICE to $TAG"
            
            # values.yamlÏóêÏÑú Ìï¥Îãπ ÏÑúÎπÑÏä§Ïùò ÌÉúÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
            case $SERVICE in
              "user-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: user-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "product-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: product-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "cart-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: cart-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "order-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: order-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "payment-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: payment-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
            esac
          done
          
          # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÌôïÏù∏
          echo "üìã Changes made:"
          git diff
          
          # Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÏúºÎ©¥ Ïª§Î∞ã & Ìë∏Ïãú
          if [ -n "$(git status --porcelain)" ]; then
            git add .
            git commit -m "Update image tags: ${{ env.built_services }}"
            git push https://${{ secrets.HELM_REPO_TOKEN }}@github.com/Kuboxer/kubox-helm-chart.git main && echo "‚úÖ Helm chart updated successfully" || echo "‚ö†Ô∏è  Failed to push helm chart changes"
          else
            echo "‚ÑπÔ∏è  No changes to commit"
          fi

  final-notification:
    name: üìä Final Status
    runs-on: ubuntu-latest
    if: ${{ always() }}
    needs: [sonarqube-analysis, manual-approval, build-and-deploy]
    steps:
      - name: üéâ Workflow Complete
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "${{ needs.build-and-deploy.result == 'success' && '#36a64f' || '#d73a49' }}",
                "title": "${{ needs.build-and-deploy.result == 'success' && 'üéâ Deployment Workflow Completed Successfully' || '‚ùå Deployment Workflow Failed' }}",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Summary",
                    "value": "‚Ä¢ SonarQube: ${{ needs.sonarqube-analysis.result == 'success' && '‚úÖ' || '‚ùå' }}\\n‚Ä¢ Approval: ${{ needs.manual-approval.result == 'success' && '‚úÖ' || '‚ùå' }}\\n‚Ä¢ Build: ${{ needs.build-and-deploy.result == 'success' && '‚úÖ' || '‚ùå' }}",
                    "short": false
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()
