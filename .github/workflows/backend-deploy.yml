name: Backend MSA Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        
      - name: Detect changed services and build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # 변경된 파일 확인
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # 변경된 서비스 찾기
          CHANGED_SERVICES=""
          
          if echo "$CHANGED_FILES" | grep -q "backend/user-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES user-service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "backend/product-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES product-service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "backend/order-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES order-service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "backend/payment-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES payment-service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "backend/cart-service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES cart-service"
          fi
          
          CHANGED_SERVICES=$(echo $CHANGED_SERVICES | xargs)
          
          if [ -z "$CHANGED_SERVICES" ]; then
            echo "No service changes detected. Skipping build."
            exit 0
          fi
          
          echo "Changed services: $CHANGED_SERVICES"
          
          for SERVICE in $CHANGED_SERVICES; do
            echo "=== Processing $SERVICE ==="
            
            # 현재 ECR의 모든 태그 조회
            echo "Current ECR tags for $SERVICE:"
            ALL_TAGS=$(aws ecr describe-images \
              --repository-name kubox \
              --query "imageDetails[?contains(imageTags, '${SERVICE}')].imageTags[]" \
              --output text 2>/dev/null | tr '\t' '\n' | sort || echo "")
            
            echo "$ALL_TAGS"
            
            # 현재 서비스의 버전 태그들만 추출 (정확한 패턴)
            VERSION_TAGS=$(echo "$ALL_TAGS" | grep "^${SERVICE}-v[0-9]*$" | sort -V || echo "")
            
            echo "Version tags for $SERVICE:"
            echo "$VERSION_TAGS"
            
            # 최고 버전 찾기
            if [ -z "$VERSION_TAGS" ]; then
              NEXT_VERSION=1
              echo "No existing versions found. Starting with v1"
            else
              # 가장 높은 버전 번호 추출
              LATEST_VERSION=$(echo "$VERSION_TAGS" | sed "s/${SERVICE}-v//" | sort -n | tail -1)
              NEXT_VERSION=$((LATEST_VERSION + 1))
              echo "Latest version: v$LATEST_VERSION"
              echo "Next version will be: v$NEXT_VERSION"
            fi
            
            # 새 버전 태그 생성
            NEW_TAG="${SERVICE}-v${NEXT_VERSION}"
            IMAGE_URI="$ECR_REGISTRY/kubox:$NEW_TAG"
            
            echo "Building new image with tag: $NEW_TAG"
            
            # 고유한 빌드 컨텍스트 생성 (태그 충돌 방지)
            BUILD_CONTEXT="build-${SERVICE}-$(date +%s)"
            mkdir -p "$BUILD_CONTEXT"
            cp -r backend/$SERVICE/* "$BUILD_CONTEXT/"
            
            # 빌드 고유성 보장
            echo "BUILD_TIME=$(date)" >> "$BUILD_CONTEXT/.buildinfo"
            echo "BUILD_VERSION=$NEW_TAG" >> "$BUILD_CONTEXT/.buildinfo"
            echo "COMMIT_SHA=${{ github.sha }}" >> "$BUILD_CONTEXT/.buildinfo"
            
            # 도커 빌드
            cd "$BUILD_CONTEXT"
            if docker build -t "$IMAGE_URI" .; then
              echo "✅ Build successful for $NEW_TAG"
              
              # 이미지 푸시
              if docker push "$IMAGE_URI"; then
                echo "✅ Successfully pushed $NEW_TAG"
                
                # latest 태그는 별도 이미지로 처리
                LATEST_TAG="${SERVICE}-latest"
                LATEST_URI="$ECR_REGISTRY/kubox:$LATEST_TAG"
                
                # latest 태그를 새 이미지에 적용
                docker tag "$IMAGE_URI" "$LATEST_URI"
                docker push "$LATEST_URI"
                echo "✅ Updated latest tag to point to $NEW_TAG"
                
                # 검증: 새로 생성된 태그 확인
                echo "Verifying new tag..."
                aws ecr describe-images \
                  --repository-name kubox \
                  --image-ids imageTag="$NEW_TAG" \
                  --query "imageDetails[0].imageTags" \
                  --output text 2>/dev/null && echo "✅ Tag verified in ECR"
                
              else
                echo "❌ Failed to push $NEW_TAG"
              fi
            else
              echo "❌ Build failed for $SERVICE"
            fi
            
            cd ..
            rm -rf "$BUILD_CONTEXT"
            
            echo "✅ Completed processing $SERVICE"
            echo "---"
          done
          
          echo ""
          echo "🎉 Build completed!"
          echo "Changed services: $CHANGED_SERVICES"
          
      - name: Final verification
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          echo "Final ECR state verification..."
          
          # 모든 kubox 이미지 태그 조회
          echo "All current tags in kubox repository:"
          aws ecr describe-images \
            --repository-name kubox \
            --query "imageDetails[].imageTags[]" \
            --output text 2>/dev/null | tr '\t' '\n' | sort || echo "No images found"
