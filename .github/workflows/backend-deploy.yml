name: Backend MSA Deploy with Strict Manual Approval

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'

jobs:
  sonarqube-analysis:
    runs-on: ubuntu-latest
    outputs:
      analysis-result: ${{ steps.sonarqube-scan.outcome }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # SonarQube를 위해 전체 히스토리 필요
        
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache SonarQube packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Make gradlew executable
        run: |
          find backend/ -name "gradlew" -exec chmod +x {} \;

      - name: Build and Test with Gradle
        run: |
          echo "🔨 Building and testing all backend services..."
          for service in backend/*/; do
            if [ -f "$service/build.gradle" ]; then
              service_name=$(basename "$service")
              echo "📦 Building $service_name..."
              cd "$service"
              ./gradlew clean build -x test  # 테스트는 별도로 실행
              ./gradlew test --continue || true  # 테스트 실패해도 계속 진행
              cd ../..
            fi
          done

      - name: Build services for SonarQube
        run: |
          echo "🔨 Building services for SonarQube analysis..."
          for service in backend/*/; do
            if [ -f "$service/build.gradle" ]; then
              service_name=$(basename "$service")
              echo "📦 Building $service_name for analysis..."
              cd "$service"
              ./gradlew clean compileJava compileTestJava
              cd ../..
            fi
          done

      - name: Run SonarQube Scan
        id: sonarqube-scan
        run: |
          # SonarQube Scanner 다운로드 및 실행
          wget -q https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip
          unzip -q sonar-scanner-cli-4.8.0.2856-linux.zip
          export PATH=$PATH:$(pwd)/sonar-scanner-4.8.0.2856-linux/bin
          
          # SonarQube 스캔 실행
          sonar-scanner \
            -Dsonar.projectKey=kubox-shopping-mall \
            -Dsonar.sources=backend \
            -Dsonar.java.binaries=backend/user-service/build/classes/java/main,backend/product-service/build/classes/java/main,backend/cart-service/build/classes/java/main,backend/order-service/build/classes/java/main,backend/payment-service/build/classes/java/main \
            -Dsonar.java.test.binaries=backend/user-service/build/classes/java/test,backend/product-service/build/classes/java/test,backend/cart-service/build/classes/java/test,backend/order-service/build/classes/java/test,backend/payment-service/build/classes/java/test \
            -Dsonar.exclusions="**/build/**,**/gradle/**,**/gradlew,**/gradlew.bat,**/.gradle/**" \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.token=${{ secrets.SONAR_TOKEN }}

      - name: Notify SonarQube Completion and Request Approval
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          custom_payload: |
            {
              "text": "✅ SonarQube Code Analysis Completed - Manual Approval Required",
              "attachments": [{
                "color": "warning",
                "fields": [{
                  "title": "Repository",
                  "value": "${{ github.repository }}",
                  "short": true
                }, {
                  "title": "Branch",
                  "value": "${{ github.ref_name }}",
                  "short": true
                }, {
                  "title": "Commit",
                  "value": "${{ github.sha }}",
                  "short": true
                }, {
                  "title": "Analysis Report",
                  "value": "Check SonarQube Dashboard for detailed results",
                  "short": false
                }, {
                  "title": "⚠️ Action Required",
                  "value": "Please review SonarQube results and manually approve deployment",
                  "short": false
                }, {
                  "title": "Approval URL",
                  "value": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                  "short": false
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # 수동 승인 단계 - 더 엄격한 설정
  manual-approval:
    name: 🔍 Manual Deployment Approval
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Display Approval Information
        run: |
          echo "🔍 Code Quality Analysis Complete!"
          echo "📊 Please check SonarQube Dashboard for detailed analysis results"
          echo ""
          echo "⏳ This deployment requires manual approval."
          echo "👥 Approved reviewers: IluvRiver, JH2050, choiyunha"
          echo ""
          echo "📋 Before approving, please verify:"
          echo "  ✅ Quality Gate Status: PASSED"
          echo "  ✅ No Critical/Major Security Issues"
          echo "  ✅ Code Coverage meets requirements"
          echo "  ✅ No Duplicated Code violations"
          echo "  ✅ Technical Debt ratio is acceptable"
          echo ""
          echo "🚀 Ready to proceed with deployment!"

      - name: Wait for Approval
        uses: 8398a7/action-slack@v3
        with:
          status: success
          custom_payload: |
            {
              "text": "⏳ Deployment is waiting for manual approval",
              "attachments": [{
                "color": "#ff9500",
                "fields": [{
                  "title": "Repository",
                  "value": "${{ github.repository }}",
                  "short": true
                }, {
                  "title": "Workflow",
                  "value": "${{ github.workflow }}",
                  "short": true
                }, {
                  "title": "Status",
                  "value": "🔍 SonarQube analysis completed successfully",
                  "short": false
                }, {
                  "title": "Waiting for",
                  "value": "Manual approval from: @IluvRiver, @JH2050, @choiyunha",
                  "short": false
                }, {
                  "title": "Review & Approve",
                  "value": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                  "short": false
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # 승인 후 빌드 및 배포
  build-and-deploy:
    name: 🚀 Build and Deploy
    needs: [sonarqube-analysis, manual-approval]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Notify Deployment Started
        uses: 8398a7/action-slack@v3
        with:
          status: success
          custom_payload: |
            {
              "text": "🚀 Deployment Approved - Starting Build Process",
              "attachments": [{
                "color": "good",
                "fields": [{
                  "title": "Repository",
                  "value": "${{ github.repository }}",
                  "short": true
                }, {
                  "title": "Branch",
                  "value": "${{ github.ref_name }}",
                  "short": true
                }, {
                  "title": "Status",
                  "value": "✅ Manual approval received. Building Docker images...",
                  "short": false
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: false
          
      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true
        
      - name: Detect services to build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          ALL_SERVICES=("user-service" "product-service" "order-service" "payment-service" "cart-service")
          BUILD_SERVICES=""
          
          # ECR에 이미지가 하나라도 있는지 확인
          TOTAL_IMAGES=$(aws ecr describe-images \
            --repository-name kubox \
            --query "length(imageDetails)" \
            --output text 2>/dev/null || echo "0")
          
          echo "Total images in ECR: $TOTAL_IMAGES"
          
          # 항상 변경 감지 로직 실행 (ECR 이미지 존재 여부와 관계없이)
          echo "🔍 Analyzing changed files to detect which services need rebuilding..."
          
          # 안전한 변경 파일 감지
          CHANGED_FILES=""
          if [ "${{ github.event_name }}" = "push" ]; then
            # Push 이벤트의 경우 이전 커밋과 비교
            if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
              echo "✅ Previous commit found, checking diff..."
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            else
              echo "⚠️  No previous commit found (first commit). Building all services."
              BUILD_SERVICES="${ALL_SERVICES[@]}"
            fi
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 수동 실행의 경우 최근 커밋 변경사항 확인
            echo "🔧 Manual workflow dispatch. Checking recent changes..."
            if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            else
              CHANGED_FILES=$(git show --name-only --format="" HEAD)
            fi
          else
            echo "📝 Other event type. Checking recent commit changes..."
            CHANGED_FILES=$(git show --name-only --format="" HEAD)
          fi
          
          # 변경된 파일이 있으면 해당 서비스만 찾기
          if [ -n "$CHANGED_FILES" ] && [ -z "$BUILD_SERVICES" ]; then
            echo "📋 Changed files:"
            echo "$CHANGED_FILES"
            echo ""
            
            # workflow 파일 자체가 변경된 경우
            if echo "$CHANGED_FILES" | grep -q ".github/workflows/backend-deploy.yml"; then
              echo "🔄 Workflow file changed. This might affect all services."
              echo "💡 However, checking for specific backend service changes..."
            fi
            
            # 각 서비스별로 변경 확인
            for SERVICE in "${ALL_SERVICES[@]}"; do
              if echo "$CHANGED_FILES" | grep -q "backend/$SERVICE/"; then
                echo "✅ Changes detected in $SERVICE"
                BUILD_SERVICES="$BUILD_SERVICES $SERVICE"
              fi
            done
            
            BUILD_SERVICES=$(echo $BUILD_SERVICES | xargs)
            
            # 백엔드 공통 파일이나 루트 레벨 변경이 있는지 확인
            if echo "$CHANGED_FILES" | grep -E "^backend/(build\.gradle|settings\.gradle|gradle|docker-compose)" >/dev/null; then
              echo "🔧 Backend common files changed. This might affect all services."
              echo "💡 But building only services with direct changes: $BUILD_SERVICES"
            fi
            
            # 변경된 백엔드 파일이 있지만 특정 서비스에 매칭되지 않는 경우
            if [ -z "$BUILD_SERVICES" ] && echo "$CHANGED_FILES" | grep -q "^backend/"; then
              echo "🤔 Backend changes detected but no specific service directory matched."
              echo "📋 Changed backend files:"
              echo "$CHANGED_FILES" | grep "^backend/" || echo "None"
              echo ""
              echo "🚀 Building all services to be safe."
              BUILD_SERVICES="${ALL_SERVICES[@]}"
            fi
            
            # 백엔드와 무관한 변경사항만 있는 경우
            if [ -z "$BUILD_SERVICES" ] && ! echo "$CHANGED_FILES" | grep -q "^backend/"; then
              echo "ℹ️  No backend-related changes detected."
              echo "📋 Changed files are:"
              echo "$CHANGED_FILES"
              echo "⏭️  Skipping backend build."
            fi
          fi
          
          if [ -z "$BUILD_SERVICES" ]; then
            echo ""
            echo "🎯 Result: No services need to be built."
            echo "build_services=" >> $GITHUB_ENV
            exit 0
          fi
          
          echo ""
          echo "🎯 Final decision: Building the following services:"
          for SERVICE in $BUILD_SERVICES; do
            echo "  📦 $SERVICE"
          done
          echo ""
          echo "build_services=$BUILD_SERVICES" >> $GITHUB_ENV
          
      - name: Build services
        id: build-services
        if: env.build_services != ''
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # 고유성을 위한 타임스탬프 (내부 빌드용)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BUILD_NUMBER="${{ github.run_number }}"
          
          # 빌드된 서비스와 버전을 저장할 배열
          BUILT_SERVICES=""
          
          for SERVICE in ${{ env.build_services }}; do
            echo "=== Processing $SERVICE ==="
            
            # 현재 서비스의 기존 버전 확인
            echo "Checking existing versions for $SERVICE..."
            EXISTING_VERSIONS=$(aws ecr describe-images \
              --repository-name kubox \
              --query "imageDetails[].imageTags[]" \
              --output text 2>/dev/null | \
              tr '\t' '\n' | \
              grep "^${SERVICE}-v[0-9]*$" | \
              sed "s/${SERVICE}-v//" | \
              sort -n || echo "")
            
            if [ -z "$EXISTING_VERSIONS" ]; then
              NEXT_VERSION=1
              echo "🆕 No existing versions found. Creating first version: v1"
            else
              echo "📋 Existing versions: $(echo $EXISTING_VERSIONS | tr '\n' ' ')"
              LATEST_VERSION=$(echo "$EXISTING_VERSIONS" | tail -1)
              NEXT_VERSION=$((LATEST_VERSION + 1))
              echo "📈 Latest version: v$LATEST_VERSION -> Next version: v$NEXT_VERSION"
            fi
            
            # 최종 태그들
            VERSION_TAG="${SERVICE}-v${NEXT_VERSION}"
            LATEST_TAG="${SERVICE}-latest"
            
            # 임시 고유 태그 (충돌 방지용)
            TEMP_TAG="${SERVICE}-temp-${TIMESTAMP}-${BUILD_NUMBER}"
            
            VERSION_URI="$ECR_REGISTRY/kubox:$VERSION_TAG"
            LATEST_URI="$ECR_REGISTRY/kubox:$LATEST_TAG"
            
            echo "🏗️  Building $SERVICE as $VERSION_TAG"
            
            # 도커 빌드 (VERSION 인자 전달)
            cd backend/$SERVICE
            
            if docker build --build-arg VERSION="$VERSION_TAG" -t "$TEMP_TAG" .; then
              echo "✅ Build successful"
              
              # 버전 태그 적용 및 푸시
              docker tag "$TEMP_TAG" "$VERSION_URI"
              if docker push "$VERSION_URI"; then
                echo "✅ Successfully pushed $VERSION_TAG"
                
                # latest 태그 적용 및 푸시
                docker tag "$TEMP_TAG" "$LATEST_URI"
                docker push "$LATEST_URI"
                echo "✅ Updated $LATEST_TAG tag"
                
                # 빌드 성공한 서비스 기록
                BUILT_SERVICES="$BUILT_SERVICES $SERVICE:$VERSION_TAG"
                
                # 결과 확인
                echo "🎯 $SERVICE is now available as:"
                echo "   📦 $VERSION_TAG"
                echo "   🏷️  $LATEST_TAG"
                
              else
                echo "❌ Failed to push $VERSION_TAG"
              fi
              
              # 임시 태그 정리
              docker rmi "$TEMP_TAG" 2>/dev/null || true
              
            else
              echo "❌ Build failed for $SERVICE"
            fi
            
            cd ../..
            echo "---"
          done

          # 빌드 결과를 환경변수로 저장
          echo "built_services=$BUILT_SERVICES" >> $GITHUB_ENV

      - name: Notify ECR Push Completion
        if: success() && env.built_services != ''
        uses: 8398a7/action-slack@v3
        with:
          status: success
          custom_payload: |
            {
              "text": "🚀 Docker Images Successfully Pushed to ECR",
              "attachments": [{
                "color": "good",
                "fields": [{
                  "title": "Repository",
                  "value": "${{ github.repository }}",
                  "short": true
                }, {
                  "title": "Branch",
                  "value": "${{ github.ref_name }}",
                  "short": true
                }, {
                  "title": "Built Services",
                  "value": "${{ env.build_services }}",
                  "short": false
                }, {
                  "title": "Updated Images",
                  "value": "${{ env.built_services }}",
                  "short": false
                }, {
                  "title": "ECR Repository",
                  "value": "${{ steps.login-ecr.outputs.registry }}/kubox",
                  "short": false
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      - name: Update Helm Chart
        if: env.built_services != ''
        run: |
          echo "🔄 Updating Helm Chart with new image tags..."
          
          # Git 설정
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # 토큰 확인 및 디버깅
          if [ -z "${{ secrets.HELM_REPO_TOKEN }}" ]; then
            echo "❌ HELM_REPO_TOKEN is not set"
            exit 1
          fi
          
          echo "✅ HELM_REPO_TOKEN is available"
          echo "🔍 Attempting to clone kubox-helm-chart repository..."
          
          # Helm Chart 저장소 클론 (상세한 에러 정보 포함)
          if git clone https://${{ secrets.HELM_REPO_TOKEN }}@github.com/Kuboxer/kubox-helm-chart.git helm-repo; then
            echo "✅ Successfully cloned helm chart repository"
          else
            echo "❌ Failed to clone helm chart repository"
            echo "🔍 Checking if repository exists..."
            curl -s -H "Authorization: token ${{ secrets.HELM_REPO_TOKEN }}" https://api.github.com/repos/Kuboxer/kubox-helm-chart || echo "Repository check failed"
            echo "⚠️  Skipping helm chart update due to clone failure"
            exit 0
          fi
          
          cd helm-repo
          
          # 빌드된 각 서비스의 태그 업데이트
          for SERVICE_TAG in ${{ env.built_services }}; do
            SERVICE=$(echo $SERVICE_TAG | cut -d':' -f1)
            TAG=$(echo $SERVICE_TAG | cut -d':' -f2)
            
            echo "📝 Updating $SERVICE to $TAG"
            
            # values.yaml에서 해당 서비스의 태그 업데이트
            case $SERVICE in
              "user-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: user-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "product-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: product-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "cart-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: cart-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "order-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: order-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
              "payment-service")
                if [ -f values.yaml ]; then
                  sed -i "s/tag: payment-service-v.*/tag: $TAG/" values.yaml
                fi
                ;;
            esac
          done
          
          # 변경사항 확인
          echo "📋 Changes made:"
          git diff
          
          # 변경사항이 있으면 커밋 & 푸시 (토큰 사용 시도, 실패하면 스킵)
          if [ -n "$(git status --porcelain)" ]; then
            git add .
            git commit -m "Update image tags: ${{ env.built_services }}"
            if [ -n "${{ secrets.HELM_REPO_TOKEN }}" ]; then
              git push https://${{ secrets.HELM_REPO_TOKEN }}@github.com/Kuboxer/kubox-helm-chart.git main && echo "✅ Helm chart updated successfully" || echo "⚠️  Failed to push helm chart changes"
            else
              echo "⚠️  HELM_REPO_TOKEN not found. Skipping helm chart push."
            fi
          else
            echo "ℹ️  No changes to commit"
          fi

  # 전체 워크플로우 결과 알림
  notification:
    name: 📊 Final Notification
    runs-on: ubuntu-latest
    if: ${{ always() }}
    needs: [sonarqube-analysis, manual-approval, build-and-deploy]
    steps:
      - name: Get workflow status
        id: check
        run: |
          if [ "${{ needs.sonarqube-analysis.result }}" == "success" ] && [ "${{ needs.manual-approval.result }}" == "success" ] && [ "${{ needs.build-and-deploy.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          elif [ "${{ needs.sonarqube-analysis.result }}" == "cancelled" ] || [ "${{ needs.manual-approval.result }}" == "cancelled" ] || [ "${{ needs.build-and-deploy.result }}" == "cancelled" ]; then
            echo "status=cancelled" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi
          
      - name: Final Workflow Notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.check.outputs.status }}
          author_name: Github Action Bot
          fields: repo,message,commit,author,action,eventName,ref,workflow,job,took
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()
